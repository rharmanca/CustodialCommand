Fix these production issues in my Custodial Command app without breaking existing functionality:

Create missing server/objectStorage.ts file:

typescript// server/objectStorage.ts
export interface ObjectStorage {
  uploadFile(file: Buffer, filename: string): Promise<string>;
  deleteFile(filename: string): Promise<boolean>;
  getFileUrl(filename: string): string;
}

export class LocalObjectStorage implements ObjectStorage {
  async uploadFile(file: Buffer, filename: string): Promise<string> {
    return `data:image/jpeg;base64,${file.toString('base64')}`;
  }

  async deleteFile(filename: string): Promise<boolean> {
    return true;
  }

  getFileUrl(filename: string): string {
    return filename;
  }
}

export const objectStorage = new LocalObjectStorage();

Add environment validation to server/index.ts (add after imports, before app creation):

typescriptconst requiredEnvVars = ['DATABASE_URL'];
const missingEnvVars = requiredEnvVars.filter(varName => !process.env[varName]);

if (missingEnvVars.length > 0) {
  logger.error('Missing required environment variables', { missing: missingEnvVars });
  process.exit(1);
}

if (!process.env.SESSION_SECRET) {
  process.env.SESSION_SECRET = require('crypto').randomBytes(32).toString('hex');
  logger.warn('Generated temporary session secret');
}

Update server/vite.ts serveStatic function to handle missing build directory:

typescriptexport function serveStatic(app: express.Application) {
  const distPath = path.join(process.cwd(), "dist/public");
  
  if (!require('fs').existsSync(distPath)) {
    logger.error('Build directory not found. Run "npm run build" first.');
    app.get("*", (req, res) => {
      if (req.path.startsWith("/api") || req.path === "/health" || req.path === "/metrics") {
        return res.status(500).json({ error: "Application not built" });
      }
      res.status(500).send('<h1>Run "npm run build" first</h1>');
    });
    return;
  }
  
  app.use(express.static(distPath));
  
  app.get("*", (req, res, next) => {
    if (req.path.startsWith("/api") || req.path === "/health" || req.path === "/metrics") {
      return next();
    }
    res.sendFile(path.join(distPath, "index.html"));
  });
}

Add React Error Boundary to src/App.tsx (add before main App component):

typescriptclass ErrorBoundary extends React.Component<{children: React.ReactNode}, {hasError: boolean}> {
  constructor(props: {children: React.ReactNode}) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(): {hasError: boolean} {
    return { hasError: true };
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="min-h-screen bg-background flex items-center justify-center p-4">
          <div className="text-center max-w-md mx-auto">
            <h1 className="text-2xl font-bold text-red-600 mb-4">Something went wrong</h1>
            <p className="text-gray-600 mb-4">Please refresh the page to try again.</p>
            <button 
              onClick={() => window.location.reload()}
              className="modern-button bg-primary hover:bg-primary/90 border-primary text-primary-foreground"
            >
              Refresh Page
            </button>
          </div>
        </div>
      );
    }
    return this.props.children;
  }
}
Then wrap your existing App return with <ErrorBoundary>...</ErrorBoundary>.

Update package.json scripts:

json"scripts": {
  "dev": "NODE_ENV=development tsx server/index.ts",
  "prebuild": "npm run check",
  "build": "vite build && esbuild server/index.ts --platform=node --packages=external --bundle --format=esm --outdir=dist",
  "prestart": "node -e \"if (!process.env.DATABASE_URL) { console.error('DATABASE_URL not set'); process.exit(1); }\"",
  "start": "NODE_ENV=production node dist/index.js",
  "check": "tsc --noEmit",
  "db:push": "drizzle-kit push"
}
Apply these changes carefully, test each one, and ensure DATABASE_URL is set in Replit Secrets before deploying.
