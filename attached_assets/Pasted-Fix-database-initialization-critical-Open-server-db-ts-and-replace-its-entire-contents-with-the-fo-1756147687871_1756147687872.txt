Fix database initialization (critical)
Open server/db.ts and replace its entire contents with the following exact file (ESM only, no require):
ts


import { drizzle } from 'drizzle-orm/neon-serverless';
import { Pool } from '@neondatabase/serverless';
import * as schema from '../shared/schema';
import dotenv from 'dotenv';

dotenv.config();

if (!process.env.DATABASE_URL) {
  throw new Error("DATABASE_URL must be set. Check your Replit Secrets tab.");
}

const pool = new Pool({ connectionString: process.env.DATABASE_URL });
export const db = drizzle(pool, { schema });
Audit and patch server routes (do not refactor broadly)
Open server/routes.ts and:
If any route references a table variable that doesn’t exist (e.g., roomInspections), replace it with the correct Drizzle tables from ../shared/schema (e.g., inspections, inspectionItems, notes, etc.). Ensure all referenced tables exist in shared/schema.ts and that imports point to ../shared/schema.
In the POST /api/inspections handler:
Log the validated payload immediately before the DB operation to aid debugging:
ts


console.log(`[${requestId}] Validated payload:`, JSON.stringify(validatedData, null, 2));
In the catch block, log the error with the requestId:
ts


console.error(`[${requestId}] Failed to create inspection:`, err);
Ensure the route returns status 201 with the created resource (or at least the new id) on success.
Do not introduce CommonJS require; keep ESM imports only.
Align validation with required fields
In the same POST /api/inspections schema, ensure these fields are accepted or defaulted:
school: z.string().optional().default("")
inspectionType: z.enum([...]).default("whole_building") or z.string().optional().default("whole_building")
locationDescription: z.string().optional().default("")
The goal: Form submissions shouldn’t 500 because these are missing. If they’re truly required, return a clean 400 with a helpful message.
Update the Whole Building Inspection form submit payload
Open src/pages/whole-building-inspection.tsx and in its submit handler:
Ensure the payload passed to createInspection includes:
school (string; default to "" if not provided by the UI)
inspectionType: "whole_building"
locationDescription (string; default to location if blank)
Example adaptation inside the submit handler:
ts


const payload = {
  ...formData,
  school: formData.school?.trim() || "",
  inspectionType: "whole_building",
  locationDescription: formData.locationDescription?.trim() || formData.location || "",
};
await createInspection(payload);
Add a simple client-side validation message if school or locationDescription is empty.
Ensure frontend API hook posts JSON correctly
Open src/hooks/use-api.tsx and confirm createInspection posts JSON and handles errors cleanly. If needed, implement:
ts


export async function createInspection(data: any) {
  const res = await fetch('/api/inspections', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!res.ok) {
    const text = await res.text().catch(() => '');
    throw new Error(`Create inspection failed: ${res.status} ${text}`);
  }
  return res.json();
}
Custodial Notes must use multipart/form-data (not JSON)
Confirm in server/routes.ts that /api/custodial-notes uses multer and expects field name images.
Ensure the frontend form for custodial notes uses FormData and does NOT set Content-Type manually:
ts


const fd = new FormData();
fd.append('inspectorName', inspectorName);
fd.append('school', school);
fd.append('date', date);
fd.append('location', location);
fd.append('locationDescription', locationDescription);
fd.append('notes', notes);
for (const file of files) fd.append('images', file); // field name must match server
await fetch('/api/custodial-notes', { method: 'POST', body: fd });
Rebuild, restart, and test
In the shell, run:
bash


pkill -f node || true
npm run build && npm start &
sleep 3
Create or update test-with-logging.js to validate /api/inspections (ESM compatible):
js


import fetch from 'node-fetch';

async function testSubmission() {
  const testData = {
    date: new Date().toISOString().slice(0,10),
    time: "09:00",
    location: "Test Location",
    inspector: "Test Inspector",
    area: "Test Area",
    score: 85,
    notes: "Test submission",
    school: "Test School",
    inspectionType: "whole_building",
    locationDescription: "Test building",
    categories: []
  };

  const res = await fetch('http://localhost:5000/api/inspections', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(testData)
  });
  console.log('Status:', res.status);
  console.log('Body:', await res.text());
}

testSubmission();
Run:
bash


node test-with-logging.js
Test Custodial Notes via curl (multipart):
bash


base64 -d > /tmp/px.png <<'B64'
iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQIHWP8z8DwHwAF/gL9Kp0P1wAAAABJRU5ErkJggg==
B64

curl -sS -X POST http://localhost:5000/api/custodial-notes \
  -F inspectorName='Test Inspector' \
  -F school='Test School' \
  -F date='2025-08-25' \
  -F location='Classroom' \
  -F locationDescription='Room 101' \
  -F notes='Test note' \
  -F images=@/tmp/px.png
If you see EADDRINUSE, do pkill -f node and retry npm start.
Optional, but helpful: add a health-check script
Create scripts/health-check.sh that:
Builds, restarts
GET /health or /, GET /api/inspections
POST a sample inspection
POST a custodial note (multipart)
Make it executable and run it. This gives you a one-command verification routine.
Do not change anything else
Do not change server/index.ts, vite config, or build outputs except where specified.
Keep ESM imports only (no require) to avoid “require is not defined” in ESM.
Deliverables
Show me the updated server/db.ts and a confirmation that:
npm run build succeeded
Server started (“Server running on port 5000”)
node test-with-logging.js shows 200/201 on POST /api/inspections
The curl multipart request for /api/custodial-notes returns 200/201
If any step fails, paste the server logs from the last 100 lines and the failing response body so I can direct the exact fix with minimal changes.