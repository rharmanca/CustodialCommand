---
phase: 03-workflow-improvements
plan: 02
type: execute
wave: 2
depends_on:
  - 03-01
files_modified:
  - server/storage.ts
  - server/routes.ts
autonomous: true

must_haves:
  truths:
    - API supports creating inspection with 'pending_review' status
    - API can list inspections filtered by 'pending_review' status
    - API allows updating pending inspection to 'completed' with full data
    - API allows discarding pending inspection
    - Pending review list loads in under 2 seconds
  artifacts:
    - path: server/storage.ts
      provides: getPendingInspections, completePendingInspection, discardInspection methods
      exports: ["getPendingInspections", "completePendingInspection", "discardPendingInspection"]
    - path: server/routes.ts
      provides: POST /api/inspections/quick-capture, GET /api/inspections/pending, PATCH /api/inspections/:id/complete, PATCH /api/inspections/:id/discard
      exports: ["quickCaptureRoute", "pendingInspectionsRoute", "completeInspectionRoute", "discardInspectionRoute"]
  key_links:
    - from: server/routes.ts
      to: server/storage.ts
      via: storage method calls
      pattern: storage\.getPendingInspections|storage\.completePendingInspection
---

<objective>
Create backend API endpoints for quick capture workflow and pending review management.

Purpose: Enable mobile app to save quick captures and desktop app to list, complete, and discard pending inspections.

Output: REST API endpoints supporting full pending review workflow with caching and validation.
</objective>

<execution_context>
@C:/Users/veloc/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/veloc/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/03-workflow-improvements/03-RESEARCH.md
@server/storage.ts
@server/routes.ts
@shared/schema.ts

## Existing Patterns
- storage.ts uses executeQuery wrapper with caching via CacheManager
- Routes use Express with Zod validation
- Inspection endpoints follow pattern: POST create, GET list with filters, GET by id, PATCH update
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add storage methods for pending review workflow</name>
  <files>server/storage.ts</files>
  <action>
    Add the following methods to storage object in server/storage.ts:

    1. `createQuickCapture(data)`:
       - Creates inspection with status 'pending_review'
       - Sets captureTimestamp to now
       - Validates required fields: school, captureLocation, inspectorName
       - Returns created inspection with cache invalidation

    2. `getPendingInspections(options)`:
       - Accepts optional filters: school, page, limit
       - Filters by status = 'pending_review'
       - Orders by captureTimestamp desc (newest first)
       - Returns paginated results with total count
       - Uses cache key: `inspections:pending:${JSON.stringify(options)}`

    3. `completePendingInspection(id, data)`:
       - Updates inspection status to 'completed'
       - Sets completionTimestamp to now
       - Accepts full inspection data (ratings, notes)
       - Validates all required fields for completed inspection
       - Invalidates relevant cache entries

    4. `discardInspection(id)`:
       - Updates inspection status to 'discarded'
       - Soft delete pattern (keeps record, just changes status)
       - Invalidates relevant cache entries

    Follow existing patterns: use executeQuery wrapper, implement proper cache invalidation, add logging.
  </action>
  <verify>npm run check passes; all new methods have proper TypeScript types and match existing patterns</verify>
  <done>Storage layer has complete pending review workflow methods with caching and logging</done>
</task>

<task type="auto">
  <name>Task 2: Create quick capture API endpoint</name>
  <files>server/routes.ts</files>
  <action>
    Add POST /api/inspections/quick-capture endpoint in server/routes.ts:

    Request body validation using Zod:
    - school: string, required
    - captureLocation: string, required (location identifier)
    - inspectorName: string, required
    - quickNotes: string, optional, max 200 chars
    - images: array of strings (photo URLs), optional

    Handler logic:
    1. Validate request body with Zod schema
    2. Call storage.createQuickCapture() with validated data
    3. Return 201 with created inspection object
    4. Handle errors with appropriate status codes and messages

    Follow existing route patterns:
    - Use validateRequest middleware if available
    - Return structured error responses: { success: false, message: string }
    - Log all operations with logger
    - Apply rate limiting considerations (existing patterns)
  </action>
  <verify>Test endpoint with curl: curl -X POST /api/inspections/quick-capture -H "Content-Type: application/json" -d '{"school":"Test School","captureLocation":"Room 101","inspectorName":"Test User"}'</verify>
  <done>POST /api/inspections/quick-capture endpoint accepts quick capture data and creates pending inspection</done>
</task>

<task type="auto">
  <name>Task 3: Create pending review list and management endpoints</name>
  <files>server/routes.ts</files>
  <action>
    Add three endpoints to server/routes.ts:

    1. GET /api/inspections/pending:
       - Query params: school (optional), page (default 1), limit (default 20)
       - Calls storage.getPendingInspections() with filters
       - Returns paginated response: { success: true, data: [], pagination: {} }

    2. PATCH /api/inspections/:id/complete:
       - Path param: id (inspection ID)
       - Request body: full inspection data (all rating fields, notes, etc.)
       - Calls storage.completePendingInspection()
       - Returns completed inspection object
       - Validates that inspection exists and is in 'pending_review' status

    3. PATCH /api/inspections/:id/discard:
       - Path param: id (inspection ID)
       - No request body required (or optional reason field)
       - Calls storage.discardInspection()
       - Returns success confirmation
       - Validates that inspection exists and is in 'pending_review' status

    All endpoints follow existing error handling patterns and return structured responses.
  </action>
  <verify>Test endpoints: GET /api/inspections/pending, PATCH /api/inspections/1/complete, PATCH /api/inspections/1/discard</verify>
  <done>Pending review endpoints support listing, completing, and discarding inspections</done>
</task>

</tasks>

<verification>
- [ ] Storage methods implemented with caching and logging
- [ ] POST /api/inspections/quick-capture creates pending inspection
- [ ] GET /api/inspections/pending returns filtered list in <2s
- [ ] PATCH /api/inspections/:id/complete moves to completed status
- [ ] PATCH /api/inspections/:id/discard moves to discarded status
- [ ] All endpoints validate input and return structured errors
- [ ] Cache invalidation works correctly on mutations
</verification>

<success_criteria>
- Quick capture endpoint accepts minimal data and creates pending inspection
- Pending list endpoint filters by status and supports pagination
- Complete endpoint transitions inspection from pending to completed with full data
- Discard endpoint soft-deletes pending inspections
- All endpoints return consistent response format: { success: boolean, data?: any, message?: string }
- Average response time <500ms for list queries, <200ms for mutations
</success_criteria>

<output>
After completion, create `.planning/phases/03-workflow-improvements/03-02-SUMMARY.md`
</output>
