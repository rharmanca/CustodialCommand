---
phase: 13-offline-sync-hardening
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - src/pages/Dashboard.tsx
  - src/utils/offlineManager.ts
autonomous: true
gap_closure: true
requirements:
  - SYNC-01
  - SYNC-02
  - SYNC-03
  - SYNC-04
must_haves:
  truths:
    - StorageWarning component is rendered in Dashboard and visible when storage exceeds 80%
    - offlineManager.uploadPhoto() performs a real POST to /api/photos/upload matching the SW pattern
  artifacts:
    - path: src/pages/Dashboard.tsx
      provides: StorageWarning rendering
      contains: StorageWarning
    - path: src/utils/offlineManager.ts
      provides: Real photo upload implementation
      contains: fetch api/photos/upload
  key_links:
    - from: src/pages/Dashboard.tsx
      to: src/components/ui/storage-warning.tsx
      via: import and render
      pattern: import.*StorageWarning
    - from: src/utils/offlineManager.ts
      to: /api/photos/upload
      via: fetch POST with FormData
      pattern: fetch.*api/photos/upload
---

<objective>
Close 3 verification gaps from Phase 13 verification: (1) wire the orphaned StorageWarning component into Dashboard.tsx, (2) replace the simulation stub in offlineManager.uploadPhoto() with a real server upload, (3) document that Quick Capture's direct fetch is acceptable since the SW handles offline interception.

Purpose: Without these fixes, storage warnings are invisible to users and the offlineManager sync path produces fake results.
Output: Two modified files that close all blocker-level gaps.
</objective>

<execution_context>
@D:/Obsidian And Projects/ClaudeCode Configuring/get-shit-done/workflows/execute-plan.md
@D:/Obsidian And Projects/ClaudeCode Configuring/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-offline-sync-hardening/13-VERIFICATION.md
@.planning/phases/13-offline-sync-hardening/13-01-SUMMARY.md
@.planning/phases/13-offline-sync-hardening/13-04-SUMMARY.md
@src/pages/Dashboard.tsx
@src/utils/offlineManager.ts
@src/types/photo.ts
@public/sw.js (lines 586-665 for syncOfflinePhotos reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire StorageWarning into Dashboard and implement real uploadPhoto</name>
  <files>src/pages/Dashboard.tsx, src/utils/offlineManager.ts</files>
  <action>
**Dashboard.tsx — Add StorageWarning import and render:**

1. Add import: `import { StorageWarning } from "@/components/ui/storage-warning";`
2. Render `<StorageWarning />` between the SyncRecovery banner (line ~61) and the responsive grid layout (line ~68). Place it as a sibling element so it appears at the top of the dashboard when storage is high. The StorageWarning component already handles its own visibility logic (hidden below 80%) so it is safe to render unconditionally.

**offlineManager.ts — Replace uploadPhoto() simulation with real implementation:**

Replace the `private async uploadPhoto(photo: PhotoStorageItem): Promise<void>` method (lines 426-441) with a real implementation that mirrors the SW's `syncOfflinePhotos()` pattern (sw.js lines 608-658):

```typescript
private async uploadPhoto(photo: PhotoStorageItem): Promise<void> {
  const formData = new FormData();

  // Convert blob to file for upload
  if (photo.blob instanceof Blob) {
    formData.append('photo', photo.blob, `photo_${photo.id}.jpg`);
  } else {
    // Fallback: if blob is somehow a string (base64 data URL)
    const blobStr = photo.blob as unknown as string;
    if (typeof blobStr === 'string' && blobStr.startsWith('data:')) {
      const response = await fetch(blobStr);
      const blob = await response.blob();
      formData.append('photo', blob, `photo_${photo.id}.jpg`);
    } else {
      throw new Error('Invalid photo data format');
    }
  }

  // Add metadata
  if (photo.metadata) {
    formData.append('metadata', JSON.stringify(photo.metadata));
  }

  // Add location data if available
  if (photo.location) {
    formData.append('location', JSON.stringify(photo.location));
  }

  // Add inspection ID if available
  if (photo.inspectionId) {
    formData.append('inspectionId', photo.inspectionId.toString());
  }

  const response = await fetch('/api/photos/upload', {
    method: 'POST',
    body: formData,
  });

  if (!response.ok) {
    throw new Error(`Photo upload failed with status ${response.status}`);
  }
}
```

Key differences from SW version: uses `photo.blob` (Blob type from PhotoStorageItem) instead of `photo.photoData` (base64 string in SW's PhotoManager schema). The SW stores photos as base64 data URLs; offlineManager's PhotoStorageItem stores them as Blob objects. Handle both cases for robustness.

Do NOT change any other methods in offlineManager.ts. The rest of syncPendingItems(), syncSingleItem(), etc. are correct — they just need uploadPhoto() to be real.

**Gap 3 (Informational — no code change needed):** Quick Capture's direct `fetch('/api/inspections/quick-capture')` bypassing offlineManager is acceptable by design. The SW intercepts this POST when offline and stores it via OfflineFormManager. The quota gate in offlineManager.savePhoto() protects the standalone photo pipeline, not the Quick Capture pipeline. Add a brief code comment in offlineManager.ts near the savePhoto() quota gate (around line 170) noting: "Note: Quick Capture uses a separate path (direct fetch intercepted by SW). This quota gate protects the standalone photo upload pipeline."
  </action>
  <verify>
1. `npx tsc --noEmit` passes (no type errors)
2. `grep -r "StorageWarning" src/pages/Dashboard.tsx` shows import and usage
3. `grep "api/photos/upload" src/utils/offlineManager.ts` shows the real endpoint
4. `grep -c "Math.random\|setTimeout.*1000" src/utils/offlineManager.ts` in the uploadPhoto method returns 0 (no simulation code)
  </verify>
  <done>
StorageWarning is imported and rendered in Dashboard.tsx (visible when storage exceeds 80%). offlineManager.uploadPhoto() POSTs to /api/photos/upload with FormData matching the SW pattern. No simulation stubs remain. TypeScript compiles clean.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `npx tsc --noEmit` passes
2. StorageWarning wired: `grep -r "StorageWarning" src/pages/Dashboard.tsx` shows import + JSX usage
3. Real upload: `grep "api/photos/upload" src/utils/offlineManager.ts` returns a match
4. No simulation: The uploadPhoto method contains no `Math.random()` or fake `setTimeout` delay
5. Build succeeds: `npm run build` completes without errors
</verification>

<success_criteria>
- StorageWarning component is rendered in Dashboard (closes Gap 1)
- offlineManager.uploadPhoto() performs real server uploads (closes Gap 2)
- Gap 3 documented with code comment (informational closure)
- TypeScript compiles clean
- All 3 verification gaps from 13-VERIFICATION.md addressed
</success_criteria>

<output>
After completion, create `.planning/phases/13-offline-sync-hardening/13-05-SUMMARY.md`
</output>
