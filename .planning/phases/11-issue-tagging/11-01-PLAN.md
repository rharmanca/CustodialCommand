---
phase: 11-issue-tagging
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/schema.ts
  - shared/tags.ts
  - server/storage.ts
  - server/routes.ts
autonomous: true

must_haves:
  truths:
    - "Tags column exists in inspections database table"
    - "createQuickCapture accepts tags parameter and persists to database"
    - "completePendingInspection accepts tags parameter and persists to database"
    - "POST /api/inspections/quick-capture accepts and validates tags"
    - "PATCH /api/inspections/:id/complete accepts and validates tags"
    - "Tag taxonomy constants are defined and exported"
  artifacts:
    - path: "shared/tags.ts"
      provides: "Tag taxonomy constants and types"
      exports: ["INSPECTION_TAGS", "InspectionTagId"]
    - path: "shared/schema.ts"
      provides: "Database schema with tags column"
      contains: ["tags: text('tags').array()", "tags: z.array(z.string())"]
    - path: "server/storage.ts"
      provides: "Storage methods with tag support"
      contains: ["createQuickCapture.*tags", "completePendingInspection.*tags"]
    - path: "server/routes.ts"
      provides: "API endpoints with tag validation"
      contains: ["/api/inspections/quick-capture", "/api/inspections/:id/complete"]
  key_links:
    - from: "shared/tags.ts"
      to: "shared/schema.ts"
      via: "import INSPECTION_TAGS for validation"
    - from: "shared/schema.ts"
      to: "server/storage.ts"
      via: "InsertInspection type includes tags"
    - from: "server/storage.ts"
      to: "server/routes.ts"
      via: "storage methods called in route handlers"
---

<objective>
Create backend foundation for issue tagging: database schema, storage layer, and API endpoints.

Purpose: Enable tags to be stored and retrieved for inspections, supporting both quick capture and full inspection workflows.
Output: Tags column in database, storage methods updated, API endpoints accepting tags.
</objective>

<execution_context>
@C:/Users/veloc/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/veloc/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@shared/schema.ts
@server/storage.ts
@server/routes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tag taxonomy constants</name>
  <files>shared/tags.ts</files>
  <action>
    Create new file shared/tags.ts with:
    1. INSPECTION_TAGS constant array with 8 tags: floors, surfaces, restrooms, trash, safety, equipment, hvac, lighting
    2. Each tag has id, label, description, and icon name (Lucide icon names)
    3. InspectionTagId type exported as typeof INSPECTION_TAGS[number]['id']
    4. Helper function validateTags(tags: string[]): string[] to filter invalid tags
    
    Use icon names: Footprints, Layers, Bath, Trash2, AlertTriangle, Wrench, Thermometer, Lightbulb
  </action>
  <verify>grep -q "INSPECTION_TAGS" shared/tags.ts && grep -q "InspectionTagId" shared/tags.ts</verify>
  <done>File exists with INSPECTION_TAGS array, InspectionTagId type, and validateTags function</done>
</task>

<task type="auto">
  <name>Task 2: Add tags column to database schema</name>
  <files>shared/schema.ts</files>
  <action>
    1. Import INSPECTION_TAGS and validateTags from './tags'
    2. Add to inspections table: tags: text("tags").array()
    3. Update insertInspectionSchema to include: tags: z.array(z.string()).optional().default([])
    4. Add index for tags: tagsIdx: index("inspections_tags_idx").on(table.tags) if supported, or skip if Drizzle doesn't support array indexes
    
    The tags field should be a PostgreSQL text array storing tag IDs.
  </action>
  <verify>grep -q "tags: text.*array" shared/schema.ts && grep -q "tags: z.array" shared/schema.ts</verify>
  <done>Inspections table has tags column, insertInspectionSchema includes tags validation</done>
</task>

<task type="auto">
  <name>Task 3: Update storage layer for tag support</name>
  <files>server/storage.ts</files>
  <action>
    Update three storage methods:
    
    1. createQuickCapture: Add optional tags parameter to data object, include in inspectionData
    2. completePendingInspection: Destructure tags from data parameter, include in updateData
    3. getInspections: Add tags filter parameter to options, add conditions for tag filtering using SQL array overlap operator
    
    For tag filtering in getInspections, use pattern like:
    if (options?.tags?.length > 0) {
      conditions.push(sql`${inspections.tags} && ${options.tags}`);
    }
    
    This uses PostgreSQL's array overlap operator && to match inspections containing any of the specified tags.
  </action>
  <verify>
    grep -q "createQuickCapture.*tags" server/storage.ts && 
    grep -q "completePendingInspection.*tags" server/storage.ts &&
    grep -q "options?.tags" server/storage.ts
  </verify>
  <done>All three storage methods handle tags parameter, tag filtering supported in getInspections</done>
</task>

<task type="auto">
  <name>Task 4: Update API endpoints for tag handling</name>
  <files>server/routes.ts</files>
  <action>
    Update two API endpoints:
    
    1. POST /api/inspections/quick-capture:
       - Add tags: z.array(z.string()).optional() to quickCaptureSchema
       - Pass validatedData.tags to storage.createQuickCapture
    
    2. PATCH /api/inspections/:id/complete:
       - Destructure tags from req.body
       - Pass tags in data object to storage.completePendingInspection
    
    Both endpoints should accept tags as string array of tag IDs.
  </action>
  <verify>
    grep -A 5 "quick-capture" server/routes.ts | grep -q "tags" &&
    grep -A 5 "complete.*PATCH" server/routes.ts | grep -q "tags"
  </verify>
  <done>Both API endpoints accept tags parameter and pass to storage layer</done>
</task>

</tasks>

<verification>
1. TypeScript compilation: npm run check passes
2. Tag taxonomy file exports constants and types
3. Database schema includes tags column
4. Storage methods accept tags parameter
5. API endpoints validate and pass tags
</verification>

<success_criteria>
- shared/tags.ts exists with 8-tag taxonomy
- shared/schema.ts has tags column in inspections table
- server/storage.ts methods accept tags parameter
- server/routes.ts endpoints handle tags
- npm run check passes with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/11-issue-tagging/11-01-SUMMARY.md`
</output>
