---
phase: 13-offline-sync-hardening
plan: 04
type: execute
wave: 3
depends_on: [13-01, 13-02, 13-03]
files_modified:
  - src/utils/syncState.ts
  - public/sw.js
  - src/utils/offlineManager.ts
  - src/hooks/useSyncRecovery.ts
  - src/components/ui/sync-recovery.tsx
autonomous: false
must_haves:
  truths:
    - Data is preserved if app closes during sync
    - Partial uploads resume from where they left off
    - User is notified of sync conflicts
    - Recovery handles interrupted sync gracefully
  artifacts:
    - path: src/utils/syncState.ts
      provides: Sync state persistence
      exports: ["saveSyncState", "getSyncState", "clearSyncState"]
    - path: src/hooks/useSyncRecovery.ts
      provides: Sync recovery hook
      exports: ["useSyncRecovery"]
    - path: src/components/ui/sync-recovery.tsx
      provides: Recovery UI component
      exports: ["SyncRecovery"]
    - path: public/sw.js
      provides: Updated with resume logic
      min_changes: 20
  key_links:
    - from: src/utils/offlineManager.ts
      to: src/utils/syncState.ts
      via: sync state persistence
      pattern: "saveSyncState|getSyncState"
    - from: src/hooks/useSyncRecovery.ts
      to: src/utils/syncState.ts
      via: state retrieval
      pattern: "getSyncState"
    - from: public/sw.js
      to: PhotoManager
      via: resume logic
      pattern: "getSyncState|resumeSync"
---

<objective>
Implement data consistency hardening to ensure sync survives app closure and handles edge cases like partial uploads and conflicts.

Purpose: Custodial staff may close the app or lose connection mid-sync. This plan ensures captures are not lost and sync resumes intelligently when the app reopens, maintaining data integrity.

Output: Sync state persistence, recovery mechanism, and conflict handling for robust offline synchronization.
</objective>

<execution_context>
@C:/Users/veloc/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/veloc/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/13-offline-sync-hardening/13-CONTEXT.md
@.planning/phases/13-offline-sync-hardening/13-RESEARCH.md
@public/sw.js
@src/utils/offlineManager.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sync state persistence utilities</name>
  <files>src/utils/syncState.ts</files>
  <action>Create sync state persistence utilities:

1. SyncState interface:
```typescript
interface SyncState {
  inProgress: boolean;
  currentItemId: string | null;
  itemType: 'photo' | 'form' | null;
  startedAt: number;
  completedItems: string[];
  failedItems: string[];
  lastUpdated: number;
}
```

2. Functions to export:
```typescript
export async function saveSyncState(state: SyncState): Promise<void>
export async function getSyncState(): Promise<SyncState | null>
export async function clearSyncState(): Promise<void>
export async function resumeSync(): Promise<boolean>
```

3. Implementation details:
   - Store in IndexedDB (separate store from photos/forms)
   - Store name: 'sync-state'
   - Save before each item upload starts
   - Clear on successful completion of all items
   - Resume function returns true if there was incomplete sync

4. Sync state lifecycle:
   - START: Set inProgress=true, currentItemId=item.id
   - PROGRESS: Add to completedItems on success
   - FAILURE: Add to failedItems, continue with next
   - COMPLETE: Clear sync state when all done
   - INTERRUPT: State remains in IndexedDB

5. Database schema:
   - Store: 'sync-state' with keyPath 'id'
   - Single record with id='current'
   - Version management for schema changes

6. Error handling:
   - Wrap in try-catch
   - Log errors but don't fail sync
   - Fallback to memory-only if IndexedDB fails</action>
  <verify>npm run check passes, types correct</verify>
  <done>Utilities created with IndexedDB storage, resume detection</done>
</task>

<task type="auto">
  <name>Task 2: Update Service Worker with resume logic</name>
  <files>public/sw.js</files>
  <action>Update sw.js to handle sync resumption:

1. Add SyncStateManager class:
```javascript
class SyncStateManager {
  static storeName = 'sync-state';
  // Methods: save, get, clear, resume
}
```

2. Modify syncOfflinePhotos() to:
   - Save state before each photo upload: `SyncStateManager.save({...})`
   - Update completedItems on success
   - Add to failedItems on failure (don't retry immediately)
   - Clear state when all photos processed

3. Add resume detection:
   - On 'activate' event, check for incomplete sync
   - If found, log: "Resuming interrupted sync"
   - Schedule immediate sync attempt

4. Modify syncOfflineForms() similarly

5. Add chunk upload support for large photos:
   - If photo > 1MB, track upload progress
   - Resume from last successful chunk
   - Store chunk index in sync state

6. Update message handlers:
   - Add 'CHECK_SYNC_STATE' handler
   - Return current sync state to client
   - Add 'CLEAR_SYNC_STATE' handler

7. Ensure backward compatibility:
   - Existing sync logic continues to work
   - New features are additive

8. Changes to make:
   - Add SyncStateManager class (lines ~200)
   - Modify syncOfflinePhotos to save state (in existing function)
   - Add activate event handler for resume (lines ~375)
   - Add message handlers (at end of message event)

Reference existing PhotoManager/OfflineFormManager patterns.</action>
  <verify>npm run check passes, sw.js syntax valid</verify>
  <done>Service Worker updated with sync state persistence and resume logic</done>
</task>

<task type="auto">
  <name>Task 3: Create useSyncRecovery hook</name>
  <files>src/hooks/useSyncRecovery.ts</files>
  <action>Create useSyncRecovery hook:

1. Hook return interface:
```typescript
interface SyncRecoveryState {
  needsRecovery: boolean;
  interruptedItem: { id: string; type: 'photo' | 'form' } | null;
  completedCount: number;
  failedCount: number;
  recoveryMessage: string;
  dismissRecovery: () => void;
  retryInterrupted: () => Promise<void>;
}
```

2. Hook behavior:
   - Check sync state on mount
   - If inProgress && currentItemId, set needsRecovery=true
   - Calculate message: "Sync was interrupted. X items completed, Y items pending."
   - Expose dismissRecovery to hide message
   - Expose retryInterrupted to resume

3. Recovery flow:
   - Check state: `getSyncState()`
   - If interrupted: show recovery UI
   - On retry: call offlineManager.syncPendingItems()
   - Clear state on completion

4. Conflict detection:
   - Check if item was modified on server since local save
   - Compare timestamps (local.captureTimestamp vs server.updatedAt)
   - If server newer, set conflict=true

5. Hook exports:
   ```typescript
   export function useSyncRecovery(): SyncRecoveryState
   ```

6. Polling:
   - Check every 10 seconds for state changes
   - Listen for service worker messages

7. Usage pattern:
   - Use in Dashboard or App component
   - Shows recovery banner when needed
   - User clicks "Resume Sync" to continue</action>
  <verify>npm run check passes</verify>
  <done>Hook created with recovery detection, conflict handling, retry methods</done>
</task>

<task type="auto">
  <name>Task 4: Create SyncRecovery component</name>
  <files>src/components/ui/sync-recovery.tsx</files>
  <action>Create SyncRecovery component:

1. Props:
```typescript
interface SyncRecoveryProps {
  onDismiss?: () => void;
}
```

2. Component behavior:
   - Shows only when needsRecovery is true
   - Displays recovery banner with info
   - Shows "Resume Sync" primary button
   - Shows "Dismiss" secondary button

3. Banner content:
   - Title: "Sync Interrupted"
   - Message: "X of Y items uploaded before connection was lost."
   - Shows list of pending items (collapsed by default)
   - Shows failed items if any

4. Visual design:
   - Amber warning banner (bg-amber-50)
   - Icon: AlertTriangle
   - Fixed position or inline based on context
   - Mobile: full width, sticky bottom

5. States:
   - Initial: Show recovery info
   - Resuming: Show spinner with "Resuming sync..."
   - Success: Show "Sync complete!" with checkmark, auto-dismiss after 3s
   - Error: Show error message with retry button

6. Accessibility:
   - role="alert"
   - aria-live="polite"
   - Focus management (move focus to banner when shown)

7. Styling:
   - Match existing alert/banner patterns
   - Ensure 44px touch targets
   - Mobile-first design

8. Example usage:
   ```tsx
   <SyncRecovery onDismiss={() => setShowRecovery(false)} />
   ```</action>
  <verify>npm run check passes, all states render</verify>
  <done>Component with recovery banner, resume button, state transitions</done>
</task>

<task type="auto">
  <name>Task 5: Update offlineManager with state integration</name>
  <files>src/utils/offlineManager.ts</files>
  <action>Update offlineManager to use sync state:

1. Import syncState utilities
2. Modify syncPendingItems() to:
   - Save state before starting
   - Update state after each item
   - Clear state on completion
   - Handle resume: check for existing state first

3. Add recovery method:
   ```typescript
   async resumeInterruptedSync(): Promise<boolean>
   ```
   - Checks for existing sync state
   - If found, resumes from where it left off
   - Returns true if resumed, false if nothing to resume

4. Add conflict resolution:
   ```typescript
   async resolveConflict(itemId: string, strategy: 'local' | 'server'): Promise<void>
   ```
   - Used when server data differs from local
   - 'local' keeps local version
   - 'server' replaces with server version

5. Update event emissions:
   - Emit 'syncResumed' when resuming
   - Emit 'syncInterrupted' when incomplete
   - Emit 'conflict' when conflict detected

6. Ensure backward compatibility:
   - All existing methods work unchanged
   - New methods are additive

7. Integration points:
   - Call saveSyncState() at start of sync
   - Call clearSyncState() at end
   - Update state after each item completion</action>
  <verify>npm run check passes, imports resolve</verify>
  <done>offlineManager updated with state persistence and recovery</done>
</task>

<task type="auto">
  <name>Task 6: Integrate recovery into Dashboard</name>
  <files>src/pages/Dashboard.tsx</files>
  <action>Add sync recovery to Dashboard:

1. Import SyncRecovery component
2. Import useSyncRecovery hook
3. Use hook to get recovery state:
   ```tsx
   const { needsRecovery, dismissRecovery } = useSyncRecovery();
   ```
4. Conditionally render SyncRecovery:
   ```tsx
   {needsRecovery && (
     <SyncRecovery onDismiss={dismissRecovery} />
   )}
   ```

5. Placement:
   - Top of Dashboard content area
   - Full width
   - Above other sections

6. Ensure it doesn't push content down abruptly:
   - Use smooth transition (animate height)
   - Or use fixed banner at top

7. Test integration:
   - Simulate interrupted sync
   - Verify recovery banner appears
   - Verify resume works
   - Verify dismiss works

8. Update Dashboard imports and types if needed</action>
  <verify>npm run check passes</verify>
  <done>SyncRecovery integrated into Dashboard, conditional rendering</done>
</task>

</tasks>

<checkpoint:human-verify gate="blocking">
  <what-built>Data consistency hardening with sync state persistence, resume from interruption, and conflict handling</what-built>
  <how-to-verify>
    1. Create a Quick Capture while online
    2. Save it (should sync immediately)
    3. Create another Quick Capture
    4. Turn off WiFi immediately after save
    5. Close the browser tab/app completely
    6. Reopen the app:
       - Verify recovery banner shows "Sync interrupted"
       - Shows correct item count
    7. Click "Resume Sync":
       - Verify sync attempts
       - May fail if still offline (expected)
    8. Turn WiFi back on:
       - Verify sync resumes automatically
       - Verify item uploads successfully
    9. Verify sync state is cleared after completion
    10. Test dismiss: click "Dismiss", verify banner closes
    11. Test conflict (if possible): modify item on server, then try to sync local version
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</checkpoint:human-verify>

<verification>
- [ ] Sync state saves before each item upload
- [ ] State persists if app closes mid-sync
- [ ] Recovery banner shows on app reopen
- [ ] Resume sync continues from where it left off
- [ ] Sync state clears on successful completion
- [ ] Conflicts are detected and handled
- [ ] Recovery can be dismissed by user
- [ ] npm run check passes
</verification>

<success_criteria>
1. Data is preserved if app closes during sync
2. Partial uploads resume from where they left off
3. Recovery UI notifies user of interrupted sync
4. User can dismiss or resume recovery
5. Sync state is cleared on completion
6. Conflicts between local and server are handled
</success_criteria>

<output>
After completion, create `.planning/phases/13-offline-sync-hardening/13-04-SUMMARY.md`
</output>
